####index.php说明
在服务上，PHP 引擎其实只执行了 index.php 这一个文件，index.php 可以抽象的看做是产品的最终型态，app 下的文件规定如何组装，system 下的文件提供基本的“组装零件”，最后拼装成一个完整的产品，这就是 index.php。

下面参考 index.php 中的具体实现来一一说明：

    <?php

    // 引入路由解析文件
    include('./system/url.php');
    // 引入常量定义文件
    include('./system/constant.php');
    // 引入框架函数库
    include('./system/function.php');

    // 解析数组拿到路径
    url::analyse($_SERVER);

    $obj = new url();
    // 加载指定文件
    include(APP.$obj->get('path').EXT);

    $class_name = $obj->get('controller');
    $func = $obj->get('func');

    $app = new $class_name();
    $app->$func();

在设计过程中，最初的划分其实是这样的：

    <?php
    1.框架环境载入

    2.框架功能执行

    3.应用功能执行

抽象的看，index.php 由如上的几个部分构成，按照规划，进一步细分就有了最上面的具体实现。

---
####文件引入
需要说明，文件的引入顺序并不重要，这些只是准备工作，谁前谁后，并没有什么区别。

**要使用工具前必须要先准备工具**。前面所说的文件引入顺序并不重要，强调的是所有引入文件之间的顺序并没有关联关系。但是，引入文件必须要在具体的执行逻辑之前，比如，下面这种写法就是错误的

    <?php
    // 解析数组拿到路径
    url::analyse($_SERVER);

    // 引入路由解析文件
    include('./system/url.php');
    // 引入常量定义文件
    include('./system/constant.php');
    // 引入框架函数库
    include('./system/function.php');

错误的原因在于，使用了还没有引入的功能组件，`url::analyse($_SERVER)` 执行时，url 类还不存在。理解这一点，需要一些更基础的知识。

#####计算机如何运行
众所周知，计算机的核心是 CPU（此处仅用来进行简略的说明，不需要的内容都被省略，更详尽的基础知识请参考其他权威资料）。

CPU 只能做以下简单的事情：
- 从寄存器读取数据；
- 计算；
- 将结果写入寄存器。

一个脚本在被载入内存（内存是一种特殊的寄存器）之后，CPU 会从头开始一条一条读取脚本并执行，CPU 只能够识别机器码（0100101111001....00011001，类似这样的由 0 和 1 组成的长串），所以 index.php 在执行之前先要进行翻译，编译成 CPU 能够识别的机器码，编译过程也是一一对应，并不会打乱顺序，编译之后的机器码可能是这样

    0100 1110
    0011 1011
    ...
    0010 0001
    1111 1111
    ...
脚本（index.php）的一行可能对应机器码中的一行或者多行。

进程（简单的理解，执行的一个程序）在执行前会被分配一片内存空间，用于存储代码、数据和临时变量。

如果 `url::analyse($_SERVER)` 在引入文件之前被执行，CPU 会在线程的内存空间中索引对应的类，而载入的动作在后面，显然是索引不到的，这样就会抛出一个错误。

这就是前面所说的，**工具必须在使用之前就准备好**，执行逻辑和载入文件之间具有同步（可以理解为具有先后顺序要求）关系。

---
####框架功能执行
具体指

    <?php
    // 解析数组拿到路径
    url::analyse($_SERVER);

    $obj = new url();
    // 加载指定文件
    include(APP.$obj->get('path').EXT);

    $class_name = $obj->get('controller');
    $func = $obj->get('func');

这一段处理了这么几个问题：
- 解析请求，拿到目标路由
- 加载目标文件
- 获取控制器，方法名

---
####应用功能执行
具体指

    <?php
    $app = new $class_name();
    $app->$func();

这是业务执行的核心，虽然所有的请求利用的是同样的逻辑，但是通过模块，控制器和方法名参数的变化，就可以实现不同业务逻辑的加载，进而实现不同的业务。